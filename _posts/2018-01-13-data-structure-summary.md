---
layout: post
title: 数据结构知识点总结
mathjax: true
tags: 应考归纳
---
记住全部知识点好难……真的要多翻书，多回顾！

**仅供个人期末回顾使用，如有错漏请谅解**

<!--more-->

#### Chapter 1. Introduction

- 数据结构是**数据元素**间的结构关系

- 数据的**逻辑结构**(4)

- 数据的**物理结构** (2)

- 算法的基本特点(5)

- 算法的**好坏**判断(4)

- 算法效率的度量(2)

  ​


#### Chapter 2. Linear List

- 顺序存储结构的移动操作是把所有插入位置的元素后移
- 链式存储插入时，头结点和尾结点都有可能同时修改
- 用数组描述的链表叫**静态链表**
- 区分用指针描述的四种链表
- 一元多项式用线性链表来表示，注意它的加法规则，同时乘法规则可以从加法规则推广



#### Chapter 3. Stack and Queue

- 栈的**先进后出**的特点

- 队列的**先进先出**的特点

- 栈的应用

  - 数制转换：因为先得到低位数，而打印是从高到低
  - 括号匹配的检验：栈顶的左括号**最迫切**等待右括号匹配
  - **表达式求值**：两个工作栈，一个存操作符，一个存操作数和运算结果

- 递归程序运用了栈的思想

  - 分治法：斐波那契数列，Hanoi塔问题
  - 回溯法：背包问题，迷宫问题

- 将递归程序转为非递归程序

- 尾递归程序的转换不需要保留参数和局部变量，可以直接用循环代替

- 循环队列的入队列和出队列的公式

- 给出栈的输入序列，判断合法的输出序列

- 用栈把中缀表达式转换成后缀表达式

  ​

#### Chapter 4. String

- 串的块链结构存储
-[ ] **串的堆分配存储表示**
- KMP模式匹配算法，求next数组和nextval数组。注意prefix和postfix不能重合
- BM算法



#### Chapter 5. Array and Lists

- 一维数组保存多维数组求元素地址
- 三元组顺序表保存稀疏矩阵，转置操作
- 三次倒转把数组内的元素循环右移K位

-[ ] 广义表的两种存储结构

- 广义表Head操作取元素，Tail操作取表
- 求广义表的深度

#### Chapter 6. Tree

- 根结点的高度是 1
- 二叉树中，$$n_0=n_2+1$$ 可以利用这个的推导过程然后推广
- k叉树中，kn是n结点的倒数第二个子树
- 完全二叉树：叶子结点的兄弟一定也是叶子，按层次遍历，如果出现了叶子结点就不可以再出现非终端结点
- 用父母指针存储二叉树时-、+表示左右子树
- 层次遍历用队列，其余用栈
- **中序遍历+前序遍历/后序遍历**唯一确定一棵树，因为可以确定叶子结点/左右孩子
- 树的直径就是两个叶子结点之间的最长路径长度
- 中序遍历给中缀表达式加括号的算法
- 寻找共同祖先可以用比较路径的方法
- 线索二叉树：一棵二叉链表表示的二叉树有n+1个空指针，线索化之前要先有树
- 树、森林与二叉树的转换：用孩子兄弟表示法，注意树的二叉链表结构和二叉树完全一致，所以对应的二叉树树根一定没有右子树；于是在森林转换成二叉树的时候就需要把树根接到二叉树的右子树上。
- 树的**先根序遍历/后根序遍历**等价于二叉树的**前序遍历/中序遍历**，所以可以唯一确定一棵树
- **通用的中序遍历**的遍历顺序第一个子树->根节点->其余子树
- **最优二叉树**就是霍夫曼树：WPL最小的树，注意构造的过程中要把新生成的树根加入原有集合进行比较
- 霍夫曼树的两个应用：最佳判定树，频率（权值）最大的结点路径最短；霍夫曼编码，平均长度减短，是**电文长度总长最短的二进制前缀编码**
- 由n个结点的组成的不相似二叉树有多少种：做题的时候用递归数，最后可以推导出公式$${1\over{n+1}}C^n_{2n}$$
- 凹入表方式打印以二叉链表表示的二叉树等价于按逆中序遍历树打印

#### Chapter 7. Graph

- 注意**弧尾**是**initial node**
- 连通分量和**强**连通分量是针对无向图和有向图的
- 图的存储结构
  - 邻接矩阵（可以有权值，有向用正负表示或者行表示弧尾列表示弧头）
  - 邻接表（表头代表顶点用顺序存储，弧结点链表存储）
  - 十字链表（邻接表的有向图形式，出度和入度分别用两条链表）
  - 邻接多重表(邻接表中的弧结点共用，减少了一半)
- 图的遍历包括DFS深度优先搜索和BFS广度优先搜索
- 判断是否存在长度为k的简单路径，用BFS
- 无向图BFS和DFS遍历可以得到不同的生成树和生成森林
- 有向图的强连通分量有两步，先正向DFS，然后按照DFS得到的逆序列，再进行逆向DFS
- 最小生成树
  - **Prim**算法：从一个点出发，将相邻的点加入选择集合
  - **Kruskal**算法：将所有的边从小到大排序并加入，判断是否存在回路；边少的时候选这个算法，因为与边数相关；该方法不用修改就可以生成森林
  - 破圈法：去掉一个回路中权值最大的边，直到不存在回路
  - 去边法：从权值大到小去掉边，不连通则保留
- 最短路径问题
  - **Dijkstra**：每次都在可达的点中选一条有最短路径并且更新别的点的路径长度；求单源点的最短路径；求所有的点之间的最短路径复杂度是$$O(n^3)$$
  -[ ] **Floyd**：每个矩阵存的是**可以通过该点而能达到的最短路径**，更新以后是需要保存新路径的，新路径是在原路径的基础上更新的；求所有的点之间的最短路径复杂度是$$O(n^3)$$
- 贪心法求背包问题：先放单位价值最大的物品
- 重复两步求拓扑排序：在有向图中输出无前驱结点，删除该点和所有以它为尾的弧。如果出现了不存在无前驱结点的情况，则说明存在环
- AOV图（有向无环）的**关键路径**是$$V_0$$到$$V_n$$的最长路径，并且不一定唯一：
  - 事件的最早/最晚开始时间：两个相等的才是关键事件（结点）
  - 活动的最早/最晚开始时间：两个相等的才是关键活动




#### Chapter 9. searching

- 动态查找表：在查找的过程中把不存在的元素插入到查找表中
- 查找操作的性能分析，用**ASL平均查找长度**来定义，指代*需要和给定值进行比较的关键字的个数的期望值*。
- 折半查找更新low/high的时候记得要由**mid+1/mid-1**
- 由折半查找延伸出不同的对有序表的分割方法

  - 斐波那契查找：mid换成比n小的$$f_u$$，平均性能比折半好，但是最坏时比折半差
  - 插值查找：mid换成$$i={K-num[low].key\over num[high].key-num.[low].key}$$，也就是有序表的关键字分布均匀的时候，我们按照比例去分割，会比折半更高效
- **最优查找树**：最先访问概率最大的结点+每次访问后应使两边未访问的结点概率之和接近
- **次优查找树**：只需要满足第二点，先找出长序列中$$\| \Delta p\| $$最小的，再找分割后得到的序列；根结点可以调整为相邻的大结点
- **索引顺序表**：索引部分为有序表，包含每个块的max key，可以用折半查找；每个小的block内是无序的
- **二叉排序树**：可以是**空树**，左子树的所有结点小于根节点，右子树大于；是一棵动态查找树，会在查找失败的时候插入
- 二叉排序的**删除操作**：叶子结点可以直接删除，只有左子树或者右子树就可以直接把子树往上升，最麻烦的是两边都有子树，就要和左边的最大结点/右边最小结点交换。
- 为了解决二叉排序树有可能**退化成线性表**的问题，引入AVL平衡二叉树，左右子树高度差小于1
- **AVL树的插入**
  - 只需要修改最小的不平衡（子）树即可，并且该（子）树的高度在调整后不变
  - 找到平衡因子绝对值为2的结点，根据正负性找到需要调整的子树；旋转，在子树中取新的树根，并且将成为新树根的结点的原有信息（**即它的二叉链表指向的左右子树**）分配到新根结点的左右子树上
- **B树的特性**
  - 根节点不是叶子的时候，至少有两棵子树
  - 根以外的所有**非终端结点**最少有$$\lceil {m\over 2} \rceil$$棵子树
  - 每个非终端结点最多有m棵子树
  - 叶子结点不含任何信息，**也就是查找不成功的信息**，并且都在**同一层**
- B树的查找分析：B树的结点存在磁盘中，结点里面的关键字存在内存中，所以结点的搜索是影响效率的首要因素，于是最坏情况就是找有N个关键字的m阶B树的最大层数，等价于**最长查找路径长度**。由于正向分析比较难，就将问题反转，变成**深度为l+1的m阶B树最少有几个结点**。
- B树的插入：当关键字大于m-1时，就把关键字$$K_{\lceil m/2 \rceil}$$和分裂出来的插入到双亲结点中，如果双亲结点也因此破坏了性质，则继续分裂。
- B树的删除：删除非终端结点关键字的时候，可以**与相邻左/右子树的最大/最小关键字交换位置**，再用删除底层结点的方法；删除某关键字时导致关键字数量小于$$\lceil {m\over 2} \rceil-1$$时，先向双亲结点借，然后用兄弟的邻近关键字补上双亲；如果这个过程中会导致兄弟结点非法，则取消该行为，向双亲取一个关键字，然后和该兄弟合并，若果这个导致双亲非法，则把这个当作是删除了双亲的结点，再次递归，<u>令双亲结点取祖父母结点中的关键字后与其兄弟合并</u>


- 性能分析

  - 顺序查找无序表：$$ASL_{成功}={n+1\over 2}$$； $$ASL_{失败}={n+1}$$ 

  - 顺序查找有序表：$$ASL_{成功}={(n+1)\over 2}$$；$$ASL_{失败}={(n+1+1)(n+1)\over 2}\times {1\over n+1}={n+2\over 2}$$

    折半查找（**一定有序**）：$$ASL_{成功}=log_2(n+1)-1$$，但是这个应该不用记，要会画出具体的查找树；失败的类型有n+1种；查找成功按层数来算，查找失败的时候要查到叶子结点才能确定失败

  - B树最大查找深度：$$   {1\over 2}log_{\lceil m/2 \rceil}{(N+1)\over 2}+1$$

- 解决冲突的几种方法

  - 开放地址法
    - **线性再散列**：直接往后加
    - 二次探测再散列：$$d_i=1^2,-1^2,2^2,-2^2...$$
    - 伪随机探测再散列：加随机数
  - 再散列法：换个别的H(KEY)再来一次直到找到空位
  - **链地址法**：H(key)相同的记录串成一条链
  - **公共区溢出法**：发生冲突的都丢到一个地方，线性往后加

- 装填因子=记录数/散列表长度


#### Chapter 10. Internal Sorting

- 插入排序
  - 直接插入：把记录一个个插到有序表中，顺序查找，老实移动
  - 折半插入：在**插入的过程**用折半查找，但是移动次数不减所以还是$$O(n^2)$$
  - 2-路插入：需要**n个辅助空间（其他插入排序都只用一个）**，减少**”原有有序表“**的移动次数，用一个**循环有序表**，大的放后，小的放前，当要插入的数是最值的时候，这个方法就没有优越性了，折半也是
  - 表插入：用静态链表来存**”原有有序表“**，于是也减少了移动次数，但是比较次数数量级不变，而且排序完后要需要把静态链表重新排列放在数组中才能用随机访问，用折半查找来查东西，注意重排可以有办法实现在原数组内，所以**不需要额外的辅助空间**
  - **希尔排序**：又称缩小增量排序，增量序列的取法是取到一个组里面最后那个取不到为止，比如增量为7，一共有12个数，那么第6个、第7个数就不用做排序；增量中一个组内做简单插入排序；增量唯一公因子是1，可以防止重复选取排序；最后一个增量取1时，整个序列一起做简单插入排序，由于整个序列**基本有序**，所以比原来的效率高

- 交换排序
  - 冒泡：每次都得到最大的关键字
  - 快排：平均性能为$$O(nlogn)$$，但是基本有序时就蜕化到$$O(n^2)$$；可以通过三者取中，或者记录高端/低端子表是否进行过交换，如果没有交换则说明有序，不需要再排序；平均情况下栈的最大深度为$$\lfloor log_2n \rfloor +1$$，<u>最坏时为n</u>，如果在一趟排序后比较子序列长度，**先对短的进行排序，然后释放空间**，则最大深度可以降为$$O(logn)$$

- 选择排序
  - 简单：移动次数最好0次，最坏3(n-1)；比较次数一定是n(n-1)/2
  - 树形：优化比较次数，锦标赛胜者树，利用之前的信息来比较，每次输出后将原来“最小关键字”最底层的结点改成最大值（$$\infty$$），再沿着原来的胜者路径往上走，这样就会把胜者树更新，并且得到次小关键字；每次选次小关键字需要$$\lceil log_2n \rceil$$次比较，所以时间复杂度是$$O(nlogn)$$，但是辅助空间要n-1个（满二叉树最底层结点数量=非终端结点数量+1）
  - 堆排序：**只需要一个辅助空间用于交换**，初始堆是序列层次遍历得到的，对初始堆的调整**从最后一个非终端结点$$\lfloor n/2 \rfloor$$开始，自下向上进行堆调整**；输出堆顶后用最后一个元素替代，然后自上向下调整

- 归并排序：从小序列开始将有序序列归并成长n的序列；需要归并$$\lceil log_2n \rceil$$趟，需要n个辅助空间用于归并

- 基数排序：先按主关键字，再按低位关键字排序，也可以反过来；链式基数排序，先按个位数排升序，再按十位数，依次往上，则最后得到的是整体升序的序列，如果要降序则要从最高位开始；需要O(rd)个辅助空间，时间复杂度为O(d(n+rd))，定义d是分裂关键字个数，rd是当前分裂关键字的取值个数，所以在**d趟分配回收**中，每趟都有n次分配，rd次收集（链表）

- 判断是否稳定排序，只需要看是否有跨元素交换的操作，如果有，则被跨过的元素中可能含有相等的元素，则不稳定

- 找到序列中前k个值的算法

- 少于2n-3次比较找到最大值和最小值

  ​

#### Chapter 11. External Sorting

- 磁带，顺序存取，将字符组成块可以提高密度；每次I/O把一整个物理块读到内存缓冲区，所以可以减少I/O操作，但是物理块过长会导致出错概率增大；在磁带上读取一块信息的时间$$T_{I/O}=t_a+n\cdot t_w$$，前者是找到物理块首地址的时间，后者是传输一个字符的时间，前者极大于后者
- 磁盘，随机存取，……
- 外部排序：将记录分为子串，分别读入内存排序后再放到外存；将归并段利用内存再归并，再输出到外存
- 归并趟数s，归并路数k，记录数n的关系：$$\lceil log_kn \rceil=s$$
- 总的读写次数=记录数（块数）\*2 +记录数（块数）\*趟数\*2
- 增加归并路数k时可以减少趟数s；但是k的增加也会增加每次得到最小关键字的比较次数，于是多路平衡归并的时候，利用**败者树**让每次找最小关键字的时间变成$$log_2k$$，败者树每次更新从叶子结点自下向上
- 置换-选择排序，是一种增加初始归并段长度，从而减少归并段数量，最终使趟数s减少的初始内排方法；每次得到的新数都比MINMAX要大，这样才属于同一个归并段；比较的过程中，先比段号，再比关键字
- 最佳归并树：如果各归并段的长度不均，发现**归并**的读写次数的两倍就是该树的WPL，于是通过建立Huffman Tree可以减少读写次数；在建立树的过程中，要利用$$n_k$$和$$n_o$$的关系来确定要不要补虚段